Notes:
associative and distributive laws and de morgan in boolean algebra
Ex. x or (y or z) = (x or y) or z (same with and) 
Ex. x and (y or z) = (x and y) or (x and z)
Idempotence value and value = value
Double negation not not x = x

From truth table to boolean function:
-start with rows with 1 and make a working expression for each row
-or all the 1 rows together
-then simplify
Sum-Of-Products, or SOP, Boolean expressions may be generated from truth tables quite easily, by determining which rows of the table have an output of 1, writing one product term for each row, and finally summing all the product terms. This creates a Boolean expression representing the truth table as a whole.
Sum-Of-Products expressions lend themselves well to implementation as a set of AND gates (products) feeding into a single OR gate (sum).
Product-Of-Sums, or POS, Boolean expressions may also be generated from truth tables quite easily, by determining which rows of the table have an output of 0, writing one sum term for each row, and finally multiplying all the sum terms. This creates a Boolean expression representing the truth table as a whole.
Product-Of-Sums expressions lend themselves well to implementation as a set of OR gates (sums) feeding into a single AND gate (product).
-add is OR
-multiply is AND

-all can represented only with not and and - in reality, nand can do everything - nand(x, x) = Not (x and x)
-Ex. Not x = x Nand x
-Ex. x and y = Not(x Nand y)

Logic Gates:
-Elementary: Nand, And, Or, Not
-Composite: bunch of elementary gates
-signals can send simultaenous signals to gates

HDL:
HDL file (we will use CHIP)
-just a textual description of chip
-functional language
-go left to right with chip diagram
-mainly VHDL and Verilog
-specify:
	-module name
	-inputs
	-outputs
	-specify implementation w/ PARTS
	-you can split signals
	-can use other gates with official names and hdl vars only
	-Ex. if use not and not's var is in, must use in=var in module
	-must name all signals
	-describe gate diagram one signal at a time and connections
Ex.
CHIP Xor
{
	IN a, b;
	OUT out;
	
	PARTS: //implementation
	Not (in=a, out=nota);
	Not (in=b, out=notb);
	And (a=a, b=notb, out=aAndNotb);
	And (a=nota, b=b, out=notaAndb);
	Or (a=aAndNotb, b=notaAndb, out=out);
}
	
-or is three nand gates 2 to 1
-array of bits, messed with together is a bus
-each bit equals a wire
-specify array with var[size]
-can access index of the bits
-specify range with x..y (Ex. 0..7)
-for this project, false and true may be used as buses of any width
-multiplexor-select signal to forward
-can make programmable gate
-only need not, or, and for multiplexor
-demultiplexor - take in input and give a or b
-can combine mux and dmux for communication
-bus - right to left

-Boolean Arithmetic and the ALU
-usually when allocated, about half of bits for negatives
-add and negative is all that you need, multiply and divide better easier at software level
-if overflow, computer usually do nothing
-Adder
-Half Adder - adds two bits
-Full Adder - adds three bits
-Adder - adds two numbers
-Half Adder:
	-takes in two bits, return two output
	-returns a sum and a carry bit
-Full Adder
	-takes in three bits, return a sum and carry bit
-Multi-bit Adder
	-start with half-adder
	-then full adders
-Negative Numbers in Binary
	-use first bit as sign bit, but problem with two zeroes
	-SO NOW TWO'S COMPLEMENT
	-negative number -x represented with 2^n - x where n is bus size
	-lose left most bit
	-probably just flip all bits to get negative and then add one
	-to add one, flip the bits from right to left, stopping the first time 0 is flipped to one
-Von Neumann Architecture
-multiple bits as input, including what function to use (predefined)
-ALU has both logical and arithmetic units
-what function to use is fed in via a truth table
-two output bits later - for HACK, there is one that tells if zero and if negative

-what we need now
-use the same hardware over and over again
-memory to store states
-need to make sure to not compute faster than physically possible
-the clock
	-convert continuous time into discrete time
	-each cycle is one digital time unit
	-sequential logic
		-just inputs labeled by time
	-choose clock to make sure things work, make sure voltage stabilize in transistor
	-use end of voltage instability region as the official state for input
-combinatorial logic vs sequential logic
-combinatorial: out[t] = function(int[t])
-sequential: out[t] = fucntion(int[t-1])
-because of sequential logic, can manuipulate to this:
	state[t] = function(state[t-1])
-can have values in same wires
-sequential logic - depends on present and previous values
-hence, sequential logic has state, or memory
-Ex.
| 1 |   2  |   3  |time
| a | f(a) | f(b) |state
a     b      c
    ->     ->
-slowest sequential logic is the clock speed
-Remember state
-need one bit of information from t-1
-can be either 0 or 1
-when go from t-1 to t, must remember its state, 0 or 1
-remembers by flipping between these possible states - Flip-Flops
-remember the flip flops
-flip flops made from nand gates - put nand gates in a loop method
-nand2tetris simulator forbids combinatorial loops, only sequential gate for loops
-sequential logic implementation
	-get combinatorial logic gate with input from t and t-1
	-send signal to array of flip flops
	-send back previous signal as t-1 and also output
-remember forever with 1-bit register
-this chip (1 bit register) is the bit chip - two inputs, input and load
-logic like this: if load(t-1) then out(t)=in(t-1) else out(t)=out(t-1)
	-so if load(t-1) is 1, then output is input at time t-1, else just keep outputting old value
	-remembers the in bit if load is set to 1
-possible implementation, need D flip flop
	-use mux plus d flip flop, load and in and return value from flip flop connect to multiplexer
-CHANGE BY NEXT CYCLE IN REGISTER
-basic memory
	-chain 1-bit register, make multi-bit register - bus size is word width
	-register;s state - value currently being expressed by internal circuit
	-get value by reading out value
	-set new value using in and set load to 1 for that value

	-RAM abstraction
	-sequence of n addressable registers with addresses 0 to n-1
	-holds registers, only one register selected at a time
	-need to select unique regiser using input called address
	-need log base 2 of n of bits for address input
	-sequential chip (has triangles in diagram)
	-read register by set address to desired address and probe the out state
	-write by set address, set in, and assert load bit
	-change by next cycle onwards
	-can select any register at same time period

-counters
	-device which stores (and sometimes displays) the number of times a particular event or process has occurred, often in relationship to a clock signal
	-helps keep track of which instruction should be fetched and executed next
	-three possible control settings - reset (Fetch first instruction), next (Fetch next instruction), goto (fetch instruction specified)
	-abstraction
		input and ouput, three control bits - reset, load, inc
	-if no control bits specified, just emit control state

-building a flip flop
	-connect to nand gates, each with their own input and one of the input being from the output of the other
	-this makes it very stable

-building the 8 register RAM
	-should send in statement to all registers first
	-then use mux and dmux to get right one

-bigger register RAM
	-stack up the ram below
	-address input can be thought of binary value with 2 fields - which RAM and which register in the selected RAM part
	-use mux and dmux

-counter
	-can use incrementer, register chips, and logic gates

-can loop in HDL, just use the variable in two different places (Ex. start and beginning)


-machine code - sequence of bits to specify instruction, register, etc.
-also have symbols for where
-include basic operations, flow control, logic, arithmetic, may have more functionality, like division and larger data types
-access memory location is expensive
	-need to supply long address and takes time
	-so use memory hierarchy, use registers, cache, main memory, disk
-registers
	-data register, and address register (connect to bigger memory)
-addressing modes (which memory to operate on)
	-can add register directly
	-can add register to memory location
	-can add register to register with memory location on bigger part
	-can add a number to a register
	-used add as an example here
-input output uses a lot of memory (ex. mouse stores last location)
-flow control
	-usually just go to next instruction (1 to 2)
	-so jump to which instruction
	-there are unconditional and conditional jump
-assembler converts assembly to machine language
-if 16 bit computer
	-all data moved in 16 bit
	-data memory - sequence of 16 bit registers
	-instruction memory - sequency of 16 bit memory
	-CPU - operate on 16 bits
	-data/instruction/address bus - 16 bit width
-for HACK machine
	-load in program, press reset, it starts running
	-3 registers, D, 16 bit data, A, 16 bit data or address, M, selected memory register in RAM
	-A and C instructions
	-A instruction -@value, where value is non-negative,a symbol referring to a constant
	Ex. @21
		-set A register to 21
		RAM[21] becomes selected RAM register
	Ex. set RAM[100] to -1
		@100
		M=-1 //selected memory register
	C instruction
		-dest, comp, jump
		-get a computation, store or jump
		-dest and jump is optional
		-comp-can do a bunch of values on 0, 1, A, D, M
		-dest - can go to: null, registers, simultaneously
		-jump register - null, JGT, JEQ, JGE, JLT, JNE, JLE, JMP - always compared to 0
		-syntax is dest = comp; jump
	-if just jump 0;JMP - language requires the ;
-can write machine language symbolically or binary code
-binary code is just opcode
	-Ex. in Hack, 0 can just be @
	-Ex. in Hack, c-instruction, start with opcode 1, two unused bits, a comp bit, dest bit, and jump bits
	-just use a cheatsheet or map 
-input output- like screen and keypad
-screen memory map - used to constantly refresh physical display
-so can manipulate some bits to change refresh cycle, can be treated as matrix
-always take out 16 bit and change and send back (first 32 rows is the first row on display for HACK)
-to set pixel (row,col): i=32*row + col/16
-for this, screen can be its own chip, access from Screen chip
-if add based on overall picture, add 16384 beforehand
-pixel can be retrieved as column % 16
-also keyboard memory map
	-just a single 16 bit register, key press goes to scan code
	-all keys represented by scan key
	-in HACK - 24576 in RAM
	-if 0, no key pressed
-assembly - mneumnoics
-use CPU Emulator for nand2tetris
-register and memory
-M is always RAM[A]
-in assembler, get rid of whitespace
-need to terminate program, else malicious code can be placed there if program doesn't terminate
	-avoid (NOP slide, null instruction/opcode attack)
	-end with infinite loop

-virutal registers too -R0, R1, R2,... R15 = 0, 1, 2, 3, 4, 5, ... 15
-HACK is case sensitive

-now, let's go to branching, variables, iteration
-branching: evaluate boolean and see if jump or move on
	-for asm, only goto stuff
	-layer the jumps correctly
-prevent unreadable code with symbolic referenes
-@LABEL loads it and (LABEL) declares that block
-assembler takes care of this, replace with instruction number
-variables, only one variable type- 16 bit register
	-in hack, can just do @var - tell computer to represent that part as this symbol
-PLEASE COMMENT FOR YOUR SANITY
-all variables allocated 16 and on wards
-this allow for re-allocatable memory, needed if multitasking
-can use anywhere in memory as long as know base memory
-loader takes care of where symbols go to in memory

-iteration
	-obvious
-always write first in pseudo code
-paranthesis is the symbolic declarator for branching

-Pointers
-add D plus M, assign to A - set addresses
-Ex. A=D+m\nM=-1
-set address register to the value of some value register (use pointer arithmetic to figure it out)
- -1 for black pixel
-read kbd to see which key is pressed
-labels is uppercase
-variables is lowercase