Notes:
associative and distributive laws and de morgan in boolean algebra
Ex. x or (y or z) = (x or y) or z (same with and) 
Ex. x and (y or z) = (x and y) or (x and z)
Idempotence value and value = value
Double negation not not x = x

From truth table to boolean function:
-start with rows with 1 and make a working expression for each row
-or all the 1 rows together
-then simplify
Sum-Of-Products, or SOP, Boolean expressions may be generated from truth tables quite easily, by determining which rows of the table have an output of 1, writing one product term for each row, and finally summing all the product terms. This creates a Boolean expression representing the truth table as a whole.
Sum-Of-Products expressions lend themselves well to implementation as a set of AND gates (products) feeding into a single OR gate (sum).
Product-Of-Sums, or POS, Boolean expressions may also be generated from truth tables quite easily, by determining which rows of the table have an output of 0, writing one sum term for each row, and finally multiplying all the sum terms. This creates a Boolean expression representing the truth table as a whole.
Product-Of-Sums expressions lend themselves well to implementation as a set of OR gates (sums) feeding into a single AND gate (product).
-add is OR
-multiply is AND

-all can represented only with not and and - in reality, nand can do everything - nand(x, x) = Not (x and x)
-Ex. Not x = x Nand x
-Ex. x and y = Not(x Nand y)

Logic Gates:
-Elementary: Nand, And, Or, Not
-Composite: bunch of elementary gates
-signals can send simultaenous signals to gates

HDL:
HDL file (we will use CHIP)
-just a textual description of chip
-functional language
-go left to right with chip diagram
-mainly VHDL and Verilog
-specify:
	-module name
	-inputs
	-outputs
	-specify implementation w/ PARTS
	-you can split signals
	-can use other gates with official names and hdl vars only
	-Ex. if use not and not's var is in, must use in=var in module
	-must name all signals
	-describe gate diagram one signal at a time and connections
Ex.
CHIP Xor
{
	IN a, b;
	OUT out;
	
	PARTS: //implementation
	Not (in=a, out=nota);
	Not (in=b, out=notb);
	And (a=a, b=notb, out=aAndNotb);
	And (a=nota, b=b, out=notaAndb);
	Or (a=aAndNotb, b=notaAndb, out=out);
}
	
-or is three nand gates 2 to 1
-array of bits, messed with together is a bus
-each bit equals a wire
-specify array with var[size]
-can access index of the bits
-specify range with x..y (Ex. 0..7)
-for this project, false and true may be used as buses of any width
-multiplexor-select signal to forward
-can make programmable gate
-only need not, or, and for multiplexor
-demultiplexor - take in input and give a or b
-can combine mux and dmux for communication
-bus - right to left

-Boolean Arithmetic and the ALU
-usually when allocated, about half of bits for negatives
-add and negative is all that you need, multiply and divide better easier at software level
-if overflow, computer usually do nothing
-Adder
-Half Adder - adds two bits
-Full Adder - adds three bits
-Adder - adds two numbers
-Half Adder:
	-takes in two bits, return two output
	-returns a sum and a carry bit
-Full Adder
	-takes in three bits, return a sum and carry bit
-Multi-bit Adder
	-start with half-adder
	-then full adders
-Negative Numbers in Binary
	-use first bit as sign bit, but problem with two zeroes
	-SO NOW TWO'S COMPLEMENT
	-negative number -x represented with 2^n - x where n is bus size
	-lose left most bit
	-probably just flip all bits to get negative and then add one
	-to add one, flip the bits from right to left, stopping the first time 0 is flipped to one
-Von Neumann Architecture
-multiple bits as input, including what function to use (predefined)
-ALU has both logical and arithmetic units
-what function to use is fed in via a truth table
-two output bits later - for HACK, there is one that tells if zero and if negative

-what we need now
-use the same hardware over and over again
-memory to store states
-need to make sure to not compute faster than physically possible
-the clock
	-convert continuous time into discrete time
	-each cycle is one digital time unit
	-sequential logic
		-just inputs labeled by time
	-choose clock to make sure things work, make sure voltage stabilize in transistor
	-use end of voltage instability region as the official state for input
-combinatorial logic vs sequential logic
-combinatorial: out[t] = function(int[t])
-sequential: out[t] = fucntion(int[t-1])
-because of sequential logic, can manuipulate to this:
	state[t] = function(state[t-1])
-can have values in same wires
-sequential logic - depends on present and previous values
-hence, sequential logic has state, or memory
-Ex.
| 1 |   2  |   3  |time
| a | f(a) | f(b) |state
a     b      c
    ->     ->
-slowest sequential logic is the clock speed
-Remember state
-need one bit of information from t-1
-can be either 0 or 1
-when go from t-1 to t, must remember its state, 0 or 1
-remembers by flipping between these possible states - Flip-Flops
-remember the flip flops
-flip flops made from nand gates - put nand gates in a loop method
-nand2tetris simulator forbids combinatorial loops, only sequential gate for loops
-sequential logic implementation
	-get combinatorial logic gate with input from t and t-1
	-send signal to array of flip flops
	-send back previous signal as t-1 and also output
-remember forever with 1-bit register
-this chip (1 bit register) is the bit chip - two inputs, input and load
-logic like this: if load(t-1) then out(t)=in(t-1) else out(t)=out(t-1)
	-so if load(t-1) is 1, then output is input at time t-1, else just keep outputting old value
	-remembers the in bit if load is set to 1
-possible implementation, need D flip flop
	-use mux plus d flip flop, load and in and return value from flip flop connect to multiplexer
-CHANGE BY NEXT CYCLE IN REGISTER
-basic memory
	-chain 1-bit register, make multi-bit register - bus size is word width
	-register;s state - value currently being expressed by internal circuit
	-get value by reading out value
	-set new value using in and set load to 1 for that value

	-RAM abstraction
	-sequence of n addressable registers with addresses 0 to n-1
	-holds registers, only one register selected at a time
	-need to select unique regiser using input called address
	-need log base 2 of n of bits for address input
	-sequential chip (has triangles in diagram)
	-read register by set address to desired address and probe the out state
	-write by set address, set in, and assert load bit
	-change by next cycle onwards
	-can select any register at same time period

-counters
	-device which stores (and sometimes displays) the number of times a particular event or process has occurred, often in relationship to a clock signal
	-helps keep track of which instruction should be fetched and executed next
	-three possible control settings - reset (Fetch first instruction), next (Fetch next instruction), goto (fetch instruction specified)
	-abstraction
		input and ouput, three control bits - reset, load, inc
	-if no control bits specified, just emit control state

-building a flip flop
	-connect to nand gates, each with their own input and one of the input being from the output of the other
	-this makes it very stable

-building the 8 register RAM
	-should send in statement to all registers first
	-then use mux and dmux to get right one

-bigger register RAM
	-stack up the ram below
	-address input can be thought of binary value with 2 fields - which RAM and which register in the selected RAM part
	-use mux and dmux

-counter
	-can use incrementer, register chips, and logic gates

-can loop in HDL, just use the variable in two different places (Ex. start and beginning)


